# ROS2
ROS, robotik uygulamalar  geliştirmek için kullanılan bir yazılım çerçevesidir. 
Robot yazılımını modüler ve yeniden kullanılabilir bileşenler halinde geliştirmeyi sağlar. 
Süreçler arası haberleşme, sensör verisi yönetimi, simülasyon, robot durumunun takibi gibi 
işlerin yapılmasını sağlar. Kısaca, robotun beynini oluşturan yazılım bileşenlerinin birbiriyle
konuşmasını organize eder.

## Temel bileşenler
### Node(Düğüm):
ROS'taki en küçük yazılım birimi. Her node tek bir sorumluluğa sahiptir. Örneğin bir node LIDAR veri okuyucusuyken diğeri haritalama yapar.

### Topic:
Node'lar arasında veri akışı sağlar. Veri akışı süreklidir. Örneğin cmd_vel.

### Publisher:
Bir node'un belirli bir topic'e mesaj gönderen kısmıdır. 

### Subscriber:
Bir node'un belirli bir topic'ten veri alan kısmıdır.

### Service:
Node'lar arasında iletişim sağlıyor ama tek seferlik bir işlem. Sürekli veri akışı sağlanmaz. Anında yanıt gereken durumlarda kullanılır. Örneğin robotu resetlemek. 

### Action:
Uzun süren ve iptal edilebilir işlemler için kullanılır. Örneğin kolun bir nesneyi kavraması.Bu işlemi gerçekleştirmek için goal, feedback ve result gerekir. Action bu bileşenlere sahiptir. 

### Parameter:
Node davranışlarını ayarlamaya yarar. 

Tüm kavramları birleştirerek bir turtle'ın belirli bir hedefe nasıl gideceğine bakalım:

turtlesim_node ile bir turtle oluşturulur. node'ların birbiriyle konuşmasını sağlayan topic'tir. Örneğin /turtle1/cmd_vel'e gönderilen hız bilgileri sürekli olarak akar ve kaplumbağa bu verilere göre hareket eder. veri akarken publisher ve subscriber kavramlarına bakmamız gerekir. turtle'ı hedefe götürmek isteyen node, /turtle1/cmd_vel topic'ine hız gönderen bir publisher'a sahiptir. Aynı node, /turtle1/pose topic'ine abone olur yani subscriber olarak bu topic'ten veri alır. Gerekirse başlangıçta bir service çağırır ve tüm davranışını parameter’lar ile ayarlayabilir. Action kavramı ise bu sürecin daha büyük ve iptal edilebilir bir görev olarak nasıl ele alınabileceğini gösterir.

## ROS1 ve ROS2 farkı
Mimarileri arasında büyük fark var. ROS1'de ROS Master bulunuyor. Node'lar birbirini doğrudan tanımıyor, master üzerinden kimin hangi veriyi yayımladığını öğreniyor. Bu da master durursa tüm sistemin durması demek. Zamanla endüstriyel kullanımda ROS1 sıkıntı yaratıyor ve ROS2 yaratım sürecine başlanıyor. 

ROS2'de Ros Master yok. Node'lar birbirini ağ üzerinden otomatik keşfediyor. Ayrıca ROS1'de mesajın ne zaman ulaşacağı, yoğunluk durumunda ne olacağı kesin değilken ROS2 gerçek zamanlı işletim sistemleriyle birlikte çalışacak şekilde tasarlandığı için algoritma daha düzgün kurulabiliyor. 

Güvenlik açısından da ROS2 daha başarılı. ROS 1'de herhangi bir node, herhangi bir topic'i  dinleyebilir. Öğrenme sürecinde pratik olsa da gerçek sistemde kabul edilemez. ROS2'de DDS Security sayesinde kimlik doğrulama, şifreleme mümkün. 

Parametre sisteminde ROS1 parametlere genel bir sunucuda tutar ve büyük sistemlerde karmaşıklığa yol açar. ROS2'de parametler node'a özeldir ve çalışma esnasında kontrollü şekilde değiştirilebilir. 

Kısaca ROS1, algoritmayı anlamak ve hızlıca denemek konusunda başarılı olsa da ROS2 gerçek sistemlerde güvenli ve zamanında çalışmayı sağlar. Algoritmayı ürüne dönüştürür.


## ROS kullanım alanları
*Mobil robotlar:* Sensör verilerinin toplanması, haritalama, konumlama ve hareket planlama süreçlerini yönetir. Veriler ROS üzerinden birleştirilir. SLAM algoritmalarıyla ortam haritası oluşturulur ve navigasyon paketleri ile robot hedefe ulaşır.

*Otonom araçlar ve insansız sistemler:* Algılama, sensör füzyonu, rota planlama ve görev yönetimi gibi modüllerin bir arada çalışmasını sağlar.

*Endüstriyel robot kolları:* Robot kolunun dinamik hesaplarını, yörünge planlamasını ve hareket kontrolünü yönetir. Özellikle MoveIt gibi kütüphaneler sayesinde nesne kavrama, montaj ve hassas pozisyonlama gibi görevler daha hızlı geliştirilebilir.

*Bilgisayarlı görü ve algılama:* Kameralardan, derinlik sensörlerinden ve lidar sistemlerinden gelen veriler ROS üzerinden işlenir. Nesne tanıma, yüz tanıma, engel algılama ve sahne analizi gibi algoritmalar ROS düğümleri olarak yapılandırılır. Bu sayede algılama modülleri, hareket ve kontrol modülleriyle doğrudan entegre çalışır.

## Otonom araçlarda ROS

ROS, otonom sürüş sisteminin farklı katmanlarını birbirine bağlayan merkezi yazılım altyapısıdır. Otonom araç temelde üç aşamada çalışır: çevreyi algılar, bu algıyı kullanarak karar verir ve aldığı kararlara göre aracı hareket ettirir. ROS, bu üç aşamanın her birinde yer alır ve özellikle bu aşamalar arasındaki veri akışını düzenler.

Algılama katmanında ROS, aracın sensörlerinden gelen verilerin ortak bir yapıda toplanmasını sağlar. Lidar, radar, kamera, GPS ve IMU gibi sensörler farklı hızlarda ve farklı formatlarda veri üretir. ROS, bu verileri birlikte yönetir ve algılama algoritmalarına düzenli bir şekilde aktarır. Nesne algılama, şerit takibi, trafik işareti tanıma gibi işlemler ROS node’ları olarak çalışır ve çıktılar yine ROS üzerinden paylaşılır.

ROS, sensör füzyonu ve lokalizasyon algoritmalarının birlikte çalışmasını kolaylaştırır. Araç yüksek hassasiyetli haritalar üzerinde kendi konumunu sürekli olarak günceller. Bu süreç, gerçek zamanlı ve kesintisiz veri akışı gerektirdiği için ROS’un haberleşme altyapısı burada öenmli rol oynar.

Karar verme ve planlama katmanında ROS, algı sonuçlarını kullanan algoritmaların bir arada çalışmasını sağlar. Yol planlama, hız planlama ve çarpışmadan kaçınma gibi modüller ayrı node’lar olarak çalışır. Çevre bilgilerini topic'ler üzerinden alır ve kararları üretir. ROS, 
modüller arasında sınır çizer ve düzenli veri akışı sağlar.

Kontrol katmanında ROS, yüksek seviyede üretilen hız ve yön komutlarının araç donanımına iletilmesinde aracı olur. Direksiyon, gaz ve fren komutları ROS üzerinden kontrol algoritmalarına iletilir. Kontrolcüler, aracın dinamiğine göre bu komutları düzenler. Bu noktada ROS, kontrol algoritmasının matematiğini belirlemez; ancak kontrol sinyallerinin doğru zamanda ve doğru bileşenlere ulaşmasını sağlar. 

Gerçek bir aracı trafiğe çıkarmadan önce, tüm algılama, planlama ve kontrol algoritmaları simülasyon ortamlarında test edilir. ROS, simülatörlerle gerçek araç arasında aynı yazılım mimarisinin kullanılmasına imkân tanır. Bu sayede simülasyonda çalışan bir algoritma, minimum değişiklikle gerçek araca taşınabilir.

ROS aynı zamanda modülerlik ve ekip çalışması açısından büyük avantaj sağlar. Otonom araç projeleri büyük ekipler tarafından geliştirilir ve herkes aynı anda tüm sistemi yazamaz. ROS, algılama, planlama ve kontrol modüllerinin birbirinden bağımsız geliştirilmesine imkan sağlar.

Kısaca otonom sürüş algoritmaları değişebilir, geliştirilebilir veya tamamen yeniden yazılabilir; ancak bu algoritmaların birlikte çalışmasını sağlayan altyapı olarak ROS, projede merkezi bir rol üstlenir.


# ROS2'ya giriş
# Test
<img width="1172" height="969" alt="Screenshot from 2025-12-12 21-58-43" src="https://github.com/user-attachments/assets/3a8b64fc-3b16-4de2-92ea-640738b3e6f3" />

## Turtlesim kullanımı 

<img width="1362" height="539" alt="Screenshot from 2025-12-12 22-59-27" src="https://github.com/user-attachments/assets/cebb44db-0f2c-4d90-a299-5bb300d3d3f8" />

ros2 run turtlesim turtlesim_nodes ---- turtle yarattı

ros2 run turtlesim turtle_teleop_key --- turtle yönlendirmemi sağladı

rqt indirdim. /spawn servisi ile yeni turtle ekleyip konumunu belirledim ayrıca /turtle1/set_pen ile kalem ayarlarını değiştirebildim.

turtle2 üzerinde ayar yapabilmek için:
ros2 run turtlesim turtle_teleop_key --ros-argss --remap turtle1/cmd_vel:=turtle2/cmd_vel 


### Komutlar

*ros2 run <package_name> <executable_name>*-- ros2 run <turtlesim> <turtlesim_node>

*ros2 node list* : aktif node'ları listeler.
/turtlesim
/teleop_turtle

*remapping işlemi:* aynı node'dan birden fazla kopyayı çakışmadan kullanmayı sağlar.

ros2 run turtlesim turtlesim_node

ros2 run turtlesim turtle_teleop_key

ros2 node list
/turtlesim
/teleop_turtle

*ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle*

ros2 node list
/turtlesim
/teleop_turtle
/my_turtle

*ros2 node info* : subscriber, publisher, services, actions vb. bilgileri verir.

*rqt_graph* : node'ları, topic'leri, aralarındaki bağlantıları görselleştirir. 
<img width="985" height="202" alt="Screenshot from 2025-12-14 11-43-52" src="https://github.com/user-attachments/assets/fdb80afe-179f-48fc-a264-e0fcb21f2810" />

*ros2 topic list -t* : topic type ile birlikte topic'leri listeler.

*ros2 topic echo <topic_name>* : *ros2 topic echo /turtle1/cmd_vel* komutu çalıştıralım. /teleop_turtle /turtlesim üzerinden /turtle1/cmd_vel ile data paylaştığı için turtle hareket ettirdiğimizde komut çalışacak ve linear, angular şeklinde x,y,z koordinatları paylaşacak.

*ros2 interface show* : topic type'ların structure'larını gösteriyor.
ros2 interface show geometry_msgs/msg/Twist -- cmd_vel'in type'ı. çıktıda linear ve angular şekilde x,y,z gösterceğini söylüyor.

robota direkt veri paylaşmak için : *ros2 topic pub <topic_name> <msg_type> '<args>'*

ros2 topic pub /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}" 

ros2 topic pub --once -w 2 /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}" -- komut sadece bir kez geçerli olsun diyorsan *--once* ekle. 

-w ile mesajı göndermeden önce kaç tane subscriber beklediğini yazarsın. *-w 2* : aynı topic'e abone olan iki tane node hazır olana kadar bekleyecek demek. örneğin, -w 2 kullanmadım ve ros2 topic pub ile hemen komut gönderdim ama ros2 topic echo o sırada çalışmıyorsa verileri alamam. 

*ros2 service call /clear std_srvs/srv/Empty* : turtlesim ekranını temizler.

ros2 service call /spawn turtlesim/srv/Spawn "{x: 2, y: 2, theta: 0.2, name: ''}" : 
turtle2 oluşturuldu, rqt ekranından da yapılabiliyor.

*ros2 param get <node_name> <parameter_name>* : parametrenin şu anki değerini gösterir

*ros2 param set <node_name> <parameter_name> <value>* : parametrenin değerini değiştirir

*ros2 param dump <node_name>* :  node'un şu anki parametre değerlerini sıralar

*ros 2 param load <node_name> <parameter_file>* : parametre yükler

*ros2 action send_goal <action_name> <action_type> <values>* : aciton server'ına bağlanır, action_type'taki hedefi gönderir ve value'ya göre işlem yapar. Terminalde feedback ve sonuç alırız.

*logger level* : node'un ürettiği hata mesajlarının önem derecesine göre gösterilmesidir. 

fatal: en kritik. sistem kapanmak zorunda.

error: ciddi problem var, sistem tam kapasite çalışmıyor.

warn: sistem çalışıyor ama potansiyel bir sorun var.

info : normal çalışma bilgisi.

debug: ayrıntılı şekilde iç işleyiş görünür.

default olarak info var. *ros2 run turtlesim turtlesim_node --ros-args --log-level WARN*
komutu ile log çıktılarının daha kritik mesajları göstermesini sağlayabiliriz. bu komutla warn, error ve fatal görünecek. info ve debug gizlenecek. 

*ros2 launch turtlesim multisim.launch.py* : iki tane turtle oluşturur

## Data kaydetme
ros2 bag kullanılır. 

*ros2 bag record /turtle1/cmd_vel* : turtle1'ın cmd_vel topic'ine gönderdiği datalar kaydediliyor.

*ros2 bag record -o subset /turtle1/cmd_vel /turtle1/pose* : -o ile dosya ismini subset olarak belirleyebildi ve şu an iki tane topic datasını kaydediyor. 

*ros2 bag play subset* : kaydettiğim veriyi tekrar okutabiliyorum 

Service'ler normalde bag ile kaydedilmiyor, introspection ile service çağrılarını topic'e çevirip kaydedebiliyorum. 

*ros2 run demo_nodes_cpp introspection_client \
  --ros-args -p client_configure_introspection:=contents*

## Workspace oluşturma
<img width="805" height="380" alt="workspace" src="https://github.com/user-attachments/assets/9f23e280-6c8c-4d13-a753-a8971ba9361e" />

mkdir -- klasör oluşturur

cd ros2_ws -- home dizininden ros2_ws klasörüne götürür

mkdir src -- workspace içinde src klasörü oluşturur, tüm paketler src içine konur

ls src -- klasör içinde dosya ya da paket olmadığını gösterir

colcon build workspace'i derlemeye çalıştı ama paket olmadığı için 0 packages finished dedi ve ros2_ws içinde build/ install/ log/ klasörlerini oluşturdu

source setup.bash ile workspace aktif hale geldi

gedit ~/.bashrc ile bashrc dosyası açıldı, bashrc içinde yazanlar terminal çalıştığında otomatik olarak komutların çalışmasını sağlıyor. 

bashrc dosyası içine source ~/ros2_ws/install/setup.bash yazarak her terminal açılışında workspace'imin aktif olmasını sağladım.

### Package oluşturma
<img width="1041" height="666" alt="Screenshot from 2025-12-14 14-18-17" src="https://github.com/user-attachments/assets/7e9857b8-18e2-424d-b823-a99b70a99067" />


### Turtlesim'e hız verisi gönderip hareket ettirme
1. *ros2 run turtlesim turtlesim_node* komutu ile turtle oluşturuldu.

2. ros2_ws adında bir workspace ve ament_python türünde turtle_py_pkg package'ı oluşturuldu.
<img width="812" height="516" alt="Screenshot from 2025-12-14 21-10-22" src="https://github.com/user-attachments/assets/9e3d0737-2b97-4a54-a211-bc3d2809dc9d" />

3. turtle'ın hızını kontrol edecek kod pyhton dilinde yazıldı.

```python
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist

topic1 = '/turtle1/cmd_vel' #mesajın yayınlanacağı topic
rate_msg = 2 #saniyede iki kez mesaj gönderilecek

def main(args = None):
    rclpy.init(args = args) #ros2 altyapısını başlatıyor, mutlaka kullan
    controlVel = Twist() #boş bir twist mesajı oluşturulur, içinde lineer ve açısal hız bileşenleri var

    controlVel.linear.x = 2.0;
    controlVel.linear.y = 0.0;
    controlVel.linear.z = 0.0;

    controlVel.angular.x = 0.0;
    controlVel.angular.y = 0.0;
    controlVel.angular.z = 0.8;

    TestNode = Node("test_node")
    publisher = TestNode.create_publisher(Twist, topic1, 1) #twist tipinde topic1'e mesaj yayınlar
    rate = TestNode.create_rate(rate_msg)

    while  rclpy.ok(): #ros çalıştığı sürece döngü devam edecek
        print("Sending control message")
        publisher.publish(controlVel) #hız mesajı topic'e gönderilir

        rclpy.spin_once(TestNode)
        rate.sleep()

    TestNode.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

package.xml dosyasına: 
```python
 <depend>rclpy</depend>
 <depend>geometry_msgs</depend>
```
eklendi. 

setup.py dosyasına
```python
    entry_points={
        'console_scripts': [
        'publisher = turtle_py_pkg.demo:main'
        ],
    },
```
eklendi.

4. *colcon build --packages-select turtle_py_pkg* komutuyla aktifleştirildi.
5.  source ~/ros2_ws/install/setup.bash
6. 
<img width="1312" height="533" alt="Screenshot from 2025-12-14 21-15-35" src="https://github.com/user-attachments/assets/9d3d5500-28ce-4f3c-8c50-041176f1177e" />

